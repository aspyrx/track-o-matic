'use strict';

/**
 * Library for interacting with the BusTime API.
 *
 * @module bustime
 */

const { URL, URLSearchParams } = require('url');
const http = require('http');

/**
 * The BusTime interface.
 *
 * @alias module:bustime
 */
class BusTime {
    /**
     * Default API base URL.
     *
     * @readonly
     * @type {string}
     */
    static get API_URL() {
        return 'http://truetime.portauthority.org/bustime/api/v3/';
    }

    /**
     * Requests the given URL and parses the JSON response according to the
     * BusTime API.
     *
     * @param {URL} url - The URL to request.
     * @returns {Promise} Resolves with an `Object` representing the parsed
     * response, or rejects with an error.
     */
    static async request(url) {
        const data = await new Promise((resolve, reject) => {
            http.get(url, res => {
                const { statusCode, headers } = res;
                const contentType = headers['content-type'];

                let err;
                if (statusCode !== 200) {
                    err = new Error(`Bad response status: ${statusCode}`);
                } else if (!/^application\/json/.test(contentType)) {
                    err = new Error(`Bad Content-Type: ${contentType}`);
                }

                if (err) {
                    res.resume();   // avoid memory leaks
                    reject(err);
                }

                res.setEncoding('utf-8');
                let body = '';
                res.on('data', chunk => {
                    body += chunk;
                });
                res.on('end', () => {
                    try {
                        resolve(JSON.parse(body));
                    } catch (e) {
                        reject(e);
                    }
                });
            }).on('error', reject);
        });

        const response = data['bustime-response'];
        if (!response) {
            throw new Error(`Malformed response data: ${data}`);
        }

        const { error } = response;
        if (error) {
            throw new Error(`Response contains error: ${error}`);
        }

        return response;
    }

    /**
     * Parses a timestamp generated by the BusTime API.
     *
     * @param {string} ts - The timestamp generated by the API.
     * @throws {Error} The timestamp must be of the form `YYYYMMDD HH:MM` or
     * `YYYYMMDD HH:MM:SS`.
     * @returns {Date} A `Date` representing the timestamp.
     */
    static parseTimestamp(ts) {
        const matches =
            // `YYYYMMDD HH:MM`, followed by optional `:SS`
            ts.match(/^(\d{4})(\d{2})(\d{2}) (\d{2}):(\d{2})(?::(\d{2}))?$/);

        if (!matches) {
            throw new Error(`Malformed timestamp: ${ts}`);
        }

        return new Date(
            matches[1],
            matches[2],
            matches[3],
            matches[4],
            matches[5],
            matches[6],
            matches[7] || 0,
            0
        );
    }

    /**
     * Initializes an API client.
     *
     * @param {Object} cfg - Configuration options.
     * @param {Object} cfg.apiKey - BusTime Developer API access key.
     * @param {Object} [cfg.apiURL=BusTime.API_URL] - BusTime API base URL.
     * @param {Object} [cfg.apiFeed] - API data feed to use, or none if not
     * specified. See BusTime developer guide, section 1.7.
     * when making requests.
     */
    constructor(cfg) {
        const {
            apiKey,
            apiURL = BusTime.API_URL,
            apiFeed
        } = cfg;

        Object.defineProperties(this,
            /** @lends module:bustime.prototype */
            {
                /**
                 * BusTime Developer API access key.
                 *
                 * @readonly
                 * @type {string}
                 */
                apiKey: { value: apiKey },

                /**
                 * BusTime API base URL.
                 *
                 * @readonly
                 * @type {string}
                 */
                apiURL: { value: apiURL },

                /**
                 * API data feed to use, or `null` if none should be used.
                 *
                 * @see BusTime developer guide, section 1.7.
                 *
                 * @readonly
                 * @type {string?}
                 */
                apiFeed: { value: apiFeed || null }
            }
        );
    }

    /**
     * Formats the API URL for the given method, using the specified options as
     * URL query parameters.
     *
     * **NOTE:**
     * - `key` is forced to `this.apiKey`.
     * - `locale` is forced to `'en'`.
     * - `format` is forced to `'json'`.
     * - If specified, `feed` overrides `opts.rtpidatafeed`.
     *
     * @private
     * @param {string} method - The API method.
     * @param {string?} feed - The API feed to use, or `null` for none.
     * @param {Object<string, string>} [opts] - The URL query parameters.
     * @returns {URL} The formatted URL.
     */
    formatURL(method, feed, opts) {
        const params = new URLSearchParams(opts);
        params.set('key', this.apiKey);
        params.set('locale', 'en');
        params.set('format', 'json');
        if (feed) {
            params.set('rtpidatafeed', feed);
        }

        const url = new URL(method, this.apiURL);
        url.search = params;

        return url;
    }

    /**
     * Gets predictions for the specified stop ID(s).
     *
     * @param {string|string[]} stpid - One or more stop ID(s).
     * @param {number} [top=4] - Maximum number of predictions to fetch.
     * @returns {Promise} Resolves with `module:bustime.Prediction[]`, or
     * rejects with an error.
     */
    async getStopPredictions(stpid, top = 4) {
        if (stpid instanceof Array) {
            stpid = stpid.join(',');
        }

        if (!stpid) {
            throw new Error('No stop IDs specified.');
        }

        const url = this.formatURL('getpredictions', this.apiFeed, {
            stpid, top
        });

        const response = await BusTime.request(url);
        return response.prd.map(prd => new BusTime.Prediction(prd));
    }
}

/**
 * Represents a prediction returned from the BusTime API.
 */
BusTime.Prediction = class {
    /**
     * Initializes the prediction with data returned from the BusTime API.
     *
     * @param {Object} prd - The prediction data.
     */
    constructor(prd) {
        const {
            tmstmp, typ, stpid, stpnm, vid, dstp, rt, rtdd, rtdir, des, prdtm,
            dly, dyn, tablockid, tatripid, prdctdn, zone, nbus
        } = prd;

        Object.defineProperties(this,
            /** @lends module:bustime.Prediction.prototype */
            {
                /**
                 * Timestamp of prediction generation.
                 *
                 * @readonly
                 * @type {Date}
                 */
                tmstmp: { value: BusTime.parseTimestamp(tmstmp) },

                /**
                 * Type of prediction. One of:
                 * - `A`: Arrival; prediction when vehicle will arrive at stop.
                 * - `D`: Departure; prediction when vehicle will depart stop.
                 *
                 * @readonly
                 * @type {string}
                 */
                typ: { value: typ },

                /**
                 * Stop ID for which this prediction was generated.
                 *
                 * @readonly
                 * @type {string}
                 */
                stpid: { value: stpid },

                /**
                 * Display name for the stop.
                 *
                 * @readonly
                 * @type {string}
                 */
                stpnm: { value: stpnm },

                /**
                 * Vehicle ID for which this prediction was generated.
                 *
                 * @readonly
                 * @type {string}
                 */
                vid: { value: vid },

                /**
                 * Linear distance in feet between vehicle and stop.
                 *
                 * @readonly
                 * @type {number}
                 */
                dstp: { value: dstp },

                /**
                 * Alphanumeric designator of the vehicle's route.
                 *
                 * @readonly
                 * @type {string}
                 */
                rt: { value: rt },

                /**
                 * Language-specific route designator.
                 *
                 * @readonly
                 * @type {string}
                 */
                rtdd: { value: rtdd },

                /**
                 * Vehicle's direction of travel on route.
                 *
                 * @readonly
                 * @type {string}
                 */
                rtdir: { value: rtdir },

                /**
                 * Name of vehicle's final destination.
                 *
                 * @readonly
                 * @type {string}
                 */
                des: { value: des },

                /**
                 * Predicted time of vehicle's arrival at stop.
                 *
                 * @readonly
                 * @type {Date}
                 */
                prdtm: { value: BusTime.parseTimestamp(prdtm) },

                /**
                 * `true` if the vehicle is delayed; `false` otherwise.
                 *
                 * @readonly
                 * @type {boolean}
                 */
                dly: { value: dly },

                /**
                 * The "dynamic action type" affecting this prediction. One of:
                 * - 0: No change.
                 * - 1: Canceled. The vehicle will not stop for this prediction.
                 * - 3: Shifted. The scheduled arrival time has changed.
                 * - 4: Expressed. The vehicle will only stop here at a rider's
                 *   request (drop-off only, no pickup).
                 *
                 * @readonly
                 * @type {number}
                 */
                dyn: { value: dyn },

                /**
                 * Transit authority internal block identifier for the scheduled
                 * work being performed by the vehicle.
                 *
                 * @readonly
                 * @type {string}
                 */
                tablockid: { value: tablockid },

                /**
                 * Transit authority internal trip identifier for the vehicle.
                 *
                 * @readonly
                 * @type {string}
                 */
                tatripid: { value: tatripid },

                /**
                 * Time left in minutes before vehicle arrives at stop.
                 *
                 * @readonly
                 * @type {number}
                 */
                prdctdn: { value: Number.parseInt(prdctdn, 10) },

                /**
                 * The vehicle's zone, or `null` if not specified.
                 *
                 * @readonly
                 * @type {string?}
                 */
                zone: { value: zone || null },

                /**
                 * If this vehicle is the last one before a service gap,
                 * represents the time left in minutes until the next vehicle's
                 * scheduled arrival; otherwise, `null`.
                 *
                 * @readonly
                 * @type {number?}
                 */
                nbus: { value: nbus || null }
            }
        );
    }

    /**
     * Converts the prediction into a human-readable string representation.
     *
     * @returns {string} A string representing the prediction.
     */
    toString() {
        const {
            rtdd, vid, rtdir, des, stpid, stpnm, prdctdn, dstp
        } = this;

        const dstr = (dstp / 5280).toFixed(1);

        return `${rtdd} (#${vid}) - ${rtdir}, ${des}: `
            + `${stpnm} (#${stpid}) - ${prdctdn}min (${dstr}mi)`;
    }
};

module.exports = BusTime;

